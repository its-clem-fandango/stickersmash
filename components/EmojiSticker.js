import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withSpring,
} from "react-native-reanimated";
import { Gesture, GestureDetector } from "react-native-gesture-handler";

/* NOTES: GestureDetector(taps,pans,etc) is responsible for detecting the user's 
interactions like dragging/tapping. Reanimated (hooks like useSharedValue and useAnimatedStyle)  is responsible for smoothly animating the componeonts in response to these interactions. It defines how the components should animate */

/* NOTES: to get gestures to work the root level component e.g. app.js must be wrapped with GestureHandlerRootView */
export default function EmojiSticker({ imageSize, stickerSource }) {
  /* NOTES: Reanimate lets you animate any of the 5 main reaect native components including: flatlist, image, view, scrollview, and text. Wrapping a component allows Reanimated to animate any prop or style associated with that component. After that you can add gestures to trigger the animations with react-native-gesture-handler  */
  const scaleImage = useSharedValue(imageSize);

  /* Translation values move the sticker around the screen. We track X and Y for both axes */
  const translateX = useSharedValue(0); //we start at 0 for this hook so that the initial position of the sticker is considered the starting point with 0
  const translateY = useSharedValue(0);

  /* Double tap gesture to scale size 2x */
  const doubleTap = Gesture.Tap()
    .numberOfTaps(2)
    .onStart(() => {
      if (scaleImage.value !== imageSize * 2) {
        scaleImage.value = scaleImage.value * 2;
      }
    });

  /* Pan gesture to move the emoji sticker around the screen */
  /* What is changeX and Y? */
  const drag = Gesture.Pan().onChange((event) => {
    /* NOTES: changeX and changeY come from the event object provided by the onChange handler in the Pan gesture. They represent the change in XY coordinates since the last event (the event object generated by react-native-gesture-handler contains details about the gesture, including how far the user has moved their finger since the last event) */
    translateX.value += event.changeX;
    translateY.value += event.changeY;
  });

  const imageStyle = useAnimatedStyle(() => {
    return {
      width: withSpring(scaleImage.value),
      height: withSpring(scaleImage.value),
    };
  });

  const containerStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateX: translateX.value,
        },
        {
          translateY: translateY.value,
        },
      ],
    };
  });

  return (
    <GestureDetector gesture={drag}>
      <Animated.View style={[containerStyle, { top: -350 }]}>
        <GestureDetector gesture={doubleTap}>
          {/*NOTES:  We apply animations to Animated.Image to make the douple tap gesture work */}
          <Animated.Image
            source={stickerSource}
            resizeMode="contain"
            /* Why is this in an array? */
            /* When you provide styles as an array, it means react native will merge the styles and apply them in the order provided. Later styles can override earlier ones if there are conflicts. Here, imageStyle is an animated style object returned by useAnimatedStyle that contains dynamic properties which can change overtime. Width and height are plain JS objects that set the width and heigth of an image. If there's any overlap between imageStyle and the objects, the last in the array take precedence */
            style={[imageStyle, { width: imageSize, height: imageSize }]}
          />
        </GestureDetector>
      </Animated.View>
    </GestureDetector>
  );
}
